/*
Gr4vy API

Welcome to the Gr4vy API reference documentation. Our API is still very much a work in product and subject to change.

API version: 1.1.0-beta
Contact: code@gr4vy.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PaymentMethodsAPIService PaymentMethodsAPI service
type PaymentMethodsAPIService service

type ApiDeletePaymentMethodRequest struct {
	ctx context.Context
	ApiService *PaymentMethodsAPIService
	paymentMethodId string
}

func (r ApiDeletePaymentMethodRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePaymentMethodExecute(r)
}

/*
DeletePaymentMethod Delete payment method

Removes a stored payment method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentMethodId The ID of the payment method.
 @return ApiDeletePaymentMethodRequest
*/
func (a *PaymentMethodsAPIService) DeletePaymentMethod(ctx context.Context, paymentMethodId string) ApiDeletePaymentMethodRequest {
	return ApiDeletePaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
		paymentMethodId: paymentMethodId,
	}
}

// Execute executes the request
func (a *PaymentMethodsAPIService) DeletePaymentMethodExecute(r ApiDeletePaymentMethodRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentMethodsAPIService.DeletePaymentMethod")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment-methods/{payment_method_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"payment_method_id"+"}", url.PathEscape(parameterValueToString(r.paymentMethodId, "paymentMethodId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPaymentMethodRequest struct {
	ctx context.Context
	ApiService *PaymentMethodsAPIService
	paymentMethodId string
}

func (r ApiGetPaymentMethodRequest) Execute() (*PaymentMethod, *http.Response, error) {
	return r.ApiService.GetPaymentMethodExecute(r)
}

/*
GetPaymentMethod Get payment method

Gets the details for a stored payment method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentMethodId The ID of the payment method.
 @return ApiGetPaymentMethodRequest
*/
func (a *PaymentMethodsAPIService) GetPaymentMethod(ctx context.Context, paymentMethodId string) ApiGetPaymentMethodRequest {
	return ApiGetPaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
		paymentMethodId: paymentMethodId,
	}
}

// Execute executes the request
//  @return PaymentMethod
func (a *PaymentMethodsAPIService) GetPaymentMethodExecute(r ApiGetPaymentMethodRequest) (*PaymentMethod, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentMethod
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentMethodsAPIService.GetPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment-methods/{payment_method_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"payment_method_id"+"}", url.PathEscape(parameterValueToString(r.paymentMethodId, "paymentMethodId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBuyerPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *PaymentMethodsAPIService
	buyerId *string
	buyerExternalIdentifier *string
	country *string
	currency *string
	sortBy *string
	orderBy *string
}

// Filters the results to only the items for which the &#x60;buyer&#x60; has an &#x60;id&#x60; that matches this value.
func (r ApiListBuyerPaymentMethodsRequest) BuyerId(buyerId string) ApiListBuyerPaymentMethodsRequest {
	r.buyerId = &buyerId
	return r
}

// Filters the results to only the items for which the &#x60;buyer&#x60; has an &#x60;external_identifier&#x60; that matches this value.
func (r ApiListBuyerPaymentMethodsRequest) BuyerExternalIdentifier(buyerExternalIdentifier string) ApiListBuyerPaymentMethodsRequest {
	r.buyerExternalIdentifier = &buyerExternalIdentifier
	return r
}

// Filters the results to only the items which support this country code. A country is formatted as 2-letter ISO country code.
func (r ApiListBuyerPaymentMethodsRequest) Country(country string) ApiListBuyerPaymentMethodsRequest {
	r.country = &country
	return r
}

// Filters the results to only the items which support this currency code. A currency is formatted as 3-letter ISO currency code.
func (r ApiListBuyerPaymentMethodsRequest) Currency(currency string) ApiListBuyerPaymentMethodsRequest {
	r.currency = &currency
	return r
}

// Used by the payment method filter to sort the results by an specific usage field.
func (r ApiListBuyerPaymentMethodsRequest) SortBy(sortBy string) ApiListBuyerPaymentMethodsRequest {
	r.sortBy = &sortBy
	return r
}

// Used to show the results ascending or descending order.
func (r ApiListBuyerPaymentMethodsRequest) OrderBy(orderBy string) ApiListBuyerPaymentMethodsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListBuyerPaymentMethodsRequest) Execute() (*PaymentMethodsTokenized, *http.Response, error) {
	return r.ApiService.ListBuyerPaymentMethodsExecute(r)
}

/*
ListBuyerPaymentMethods List payment methods for buyer

Returns a list of stored payment methods for a buyer in a summarized format.
Only payment methods that are compatible with at least one active payment
service in that region are shown.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBuyerPaymentMethodsRequest
*/
func (a *PaymentMethodsAPIService) ListBuyerPaymentMethods(ctx context.Context) ApiListBuyerPaymentMethodsRequest {
	return ApiListBuyerPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentMethodsTokenized
func (a *PaymentMethodsAPIService) ListBuyerPaymentMethodsExecute(r ApiListBuyerPaymentMethodsRequest) (*PaymentMethodsTokenized, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentMethodsTokenized
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentMethodsAPIService.ListBuyerPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/buyers/payment-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.buyerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyer_id", r.buyerId, "form", "")
	}
	if r.buyerExternalIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyer_external_identifier", r.buyerExternalIdentifier, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	} else {
		var defaultValue string = "desc"
		r.orderBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *PaymentMethodsAPIService
	buyerId *string
	buyerExternalIdentifier *string
	status *[]string
	externalIdentifier *string
	limit *int32
	cursor *string
}

// Filters the results to only the items for which the &#x60;buyer&#x60; has an &#x60;id&#x60; that matches this value.
func (r ApiListPaymentMethodsRequest) BuyerId(buyerId string) ApiListPaymentMethodsRequest {
	r.buyerId = &buyerId
	return r
}

// Filters the results to only the items for which the &#x60;buyer&#x60; has an &#x60;external_identifier&#x60; that matches this value.
func (r ApiListPaymentMethodsRequest) BuyerExternalIdentifier(buyerExternalIdentifier string) ApiListPaymentMethodsRequest {
	r.buyerExternalIdentifier = &buyerExternalIdentifier
	return r
}

// Filters the results to only the payment methods for which the &#x60;status&#x60; matches with any of the provided status values.
func (r ApiListPaymentMethodsRequest) Status(status []string) ApiListPaymentMethodsRequest {
	r.status = &status
	return r
}

// Filters the results to only the items for which the resource has an &#x60;external_identifier&#x60; that matches this value.
func (r ApiListPaymentMethodsRequest) ExternalIdentifier(externalIdentifier string) ApiListPaymentMethodsRequest {
	r.externalIdentifier = &externalIdentifier
	return r
}

// Defines the maximum number of items to return for this request.
func (r ApiListPaymentMethodsRequest) Limit(limit int32) ApiListPaymentMethodsRequest {
	r.limit = &limit
	return r
}

// A cursor that identifies the page of results to return. This is used to paginate the results of this API.  For the first page of results, this parameter can be left out. For additional pages, use the value returned by the API in the &#x60;next_cursor&#x60; field. Similarly the &#x60;previous_cursor&#x60; can be used to reverse backwards in the list.
func (r ApiListPaymentMethodsRequest) Cursor(cursor string) ApiListPaymentMethodsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiListPaymentMethodsRequest) Execute() (*PaymentMethods, *http.Response, error) {
	return r.ApiService.ListPaymentMethodsExecute(r)
}

/*
ListPaymentMethods List payment methods

Returns a list of stored payment methods.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPaymentMethodsRequest
*/
func (a *PaymentMethodsAPIService) ListPaymentMethods(ctx context.Context) ApiListPaymentMethodsRequest {
	return ApiListPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentMethods
func (a *PaymentMethodsAPIService) ListPaymentMethodsExecute(r ApiListPaymentMethodsRequest) (*PaymentMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentMethodsAPIService.ListPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.buyerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyer_id", r.buyerId, "form", "")
	}
	if r.buyerExternalIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyer_external_identifier", r.buyerExternalIdentifier, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.externalIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "external_identifier", r.externalIdentifier, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNewPaymentMethodRequest struct {
	ctx context.Context
	ApiService *PaymentMethodsAPIService
	paymentMethodRequest *PaymentMethodRequest
}

func (r ApiNewPaymentMethodRequest) PaymentMethodRequest(paymentMethodRequest PaymentMethodRequest) ApiNewPaymentMethodRequest {
	r.paymentMethodRequest = &paymentMethodRequest
	return r
}

func (r ApiNewPaymentMethodRequest) Execute() (*PaymentMethod, *http.Response, error) {
	return r.ApiService.NewPaymentMethodExecute(r)
}

/*
NewPaymentMethod New payment method

Stores and vaults a new payment method.

Vaulting a card only stores its information but doesn't validate it against any
PSP, so ephemeral data like the security code, often referred to as the CVV or
CVD, won't be used. In order to validate the card data, a CIT (Customer Initiated
Transaction) must be done, even if it's a zero-value one.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNewPaymentMethodRequest
*/
func (a *PaymentMethodsAPIService) NewPaymentMethod(ctx context.Context) ApiNewPaymentMethodRequest {
	return ApiNewPaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentMethod
func (a *PaymentMethodsAPIService) NewPaymentMethodExecute(r ApiNewPaymentMethodRequest) (*PaymentMethod, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentMethod
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentMethodsAPIService.NewPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentMethodRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error400BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error409DuplicateRecord
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
